<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Student Login â€” WebAuthn</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
<style>
body { background:#f8f9fa; }
.card { max-width:520px; margin:80px auto; padding:18px; }
.muted { color:#666; font-size:.9rem; }
</style>
</head>
<body>
<div class="card shadow-sm">
<h3 class="mb-3">ðŸ”‘ Student Login</h3>

{% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
        {% for category, message in messages %}
            <div class="alert alert-{{ 'success' if category == 'success' else 'danger' }}">{{ message }}</div>
        {% endfor %}
    {% endif %}
{% endwith %}

<p class="muted">Login using your registered security key or passkey (e.g. fingerprint, face scan, or device PIN).</p>
<form id="loginForm" method="POST" action="/student/login/verify">
<input type="hidden" name="webauthn_assertion" id="webauthn_assertion">


<div class="mb-3">
<label class="form-label">Student ID</label>
<input name="student_id" class="form-control" required />
</div>


<div id="webauthn-status" class="mb-2 muted">Checking WebAuthn availability...</div>


<div class="d-flex gap-2 mb-3">
<button id="getAssertionBtn" type="button" class="btn btn-primary w-100">Login</button>
</div>

</form>
<div class="text-center mt-3">
    <a href="{{ url_for('home') }}" class="btn btn-secondary w-100">Back to Home</a>
</div>
</div>

<script>
    // A few helpers for base64 conversions
    const bufferDecode = (value) => {
        const base64 = value.replace(/-/g, '+').replace(/_/g, '/');
        const padLength = (4 - (base64.length % 4)) % 4;
        const padded = base64.padEnd(base64.length + padLength, '=');
        const raw = atob(padded);
        return Uint8Array.from(raw, (c) => c.charCodeAt(0));
    };

    const bufferEncode = (value) =>
        btoa(String.fromCharCode.apply(null, new Uint8Array(value)))
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
            .replace(/=/g, "");

    // DOM Elements
    const statusEl = document.getElementById('webauthn-status');
    const studentIdInput = document.querySelector('input[name="student_id"]');
    const getAssertionBtn = document.getElementById('getAssertionBtn');
    const loginForm = document.getElementById('loginForm');
    const assertionInput = document.getElementById('webauthn_assertion');

    // Check for WebAuthn availability
    if (window.PublicKeyCredential) {
        statusEl.textContent = 'âœ… Passkey authentication is available on this browser.';
        getAssertionBtn.disabled = false;
    } else {
        statusEl.textContent = 'âŒ Passkey authentication is not supported on this browser. Please try a different browser.';
        getAssertionBtn.disabled = true;
    }

    // Handle WebAuthn assertion
    getAssertionBtn.addEventListener('click', async () => {
        const studentId = studentIdInput.value;
        if (!studentId) {
            alert('Please enter your Student ID');
            return;
        }

        // 1. Get options from the server
        const resp = await fetch('/student/login/options', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `student_id=${encodeURIComponent(studentId)}`
        });

        // Check if the server responded with an error (like 404 Not Found)
        if (!resp.ok) {
            const errorData = await resp.json();
            alert(errorData.error || 'An unknown error occurred. Please check the Student ID.');
            return;
        }

        let options;
        try {
            options = await resp.json();
        } catch (e) {
            alert('Failed to get login options from server.');
            return;
        }

        // 2. Turn challenge and IDs into buffers
        options.challenge = bufferDecode(options.challenge);
        if (options.allowCredentials) {
            for (let cred of options.allowCredentials) {
                cred.id = bufferDecode(cred.id);
            }
        }

        // 3. Call navigator.credentials.get()
        let credential;
        try {
            credential = await navigator.credentials.get({ publicKey: options });
        } catch (e) {
            alert('Login failed or was cancelled.');
            console.error(e);
            return;
        }

        // 4. Encode the credential to a JSON-friendly format
        const assertion = {
            id: credential.id,
            rawId: bufferEncode(credential.rawId),
            response: {
                clientDataJSON: bufferEncode(credential.response.clientDataJSON),
                authenticatorData: bufferEncode(credential.response.authenticatorData),
                signature: bufferEncode(credential.response.signature),
            },
            type: credential.type,
        };

        // 5. Populate the hidden field and submit the form
        assertionInput.value = JSON.stringify(assertion);
        loginForm.submit();
    });
</script>
</body>
</html>